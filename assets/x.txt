var verticalInput;
var horizontalInput;

var currTime;
var prevTime = new Date().getTime();
var dt;

var gi = 0;

class MultiplayerSession {
  constructor() {
    this.ships = new Map();
    this.bullets = new Map();
    this.particles = [];
    this.comets = [];
    this.asteroids = [];

    this.myShip;
    this.myId;

    this.socket = io.connect(window.location.origin);

    this.socket.on('p', //position
      function(data) {
        let sh = this.ships.get(data.id);
        if(typeof sh === 'undefined'){
          sh = new Ship(data.x,data.y);
          sh.usePseudoPos = true;
          this.ships.set(data.id, sh);
        }
        
        let timeDif = (currTime-data.time)/1000;

        sh.pPos = sh.pos.copy();

        sh.serverUpdate(data);
        sh.move(timeDif);

        sh.pVel = sh.pos.copy();
        sh.pVel.sub(sh.pPos);
        sh.pVel.div(0.1);
        sh.timeToCompensationEnd = 0.1;
      }
    );

    this.socket.on('b', //bullet
      function(data) {
        let b = new Bullet(data.a, data.x, data.y, data.s, data.id);
        this.bullets.set(data.s + data.id, b);
        
        let timeDif = (currTime-data.t)/1000;
        
        this.myShip.move(-timeDif);
        let hit = false;

        while(timeDif > 0 && !hit) {
          timeDif -= 0.01666;
          let dt = 0.01666;
          if(timeDif < 0) dt = timeDif + 0.01666;

          b.move(dt);
          this.myShip.move(dt);
          this.myShip.update();
    
          if(b.update()){
            hit = true;
          }
        }

        b.usePseudoPos = true;   
        b.pPos = this.ships.get(data.s).pos.copy();
        b.pVel = b.pos.copy();
        b.pVel.sub(b.pPos);
        b.pVel.div(0.1);
        b.timeToCompensationEnd = 0.1;
      }
    );

    this.socket.on('h', //hit
      function(data) {
        let sh = this.ships.get(data.h);
        sh.hit();
        this.bullets.delete(data.s + data.id);    
      }
    );

    this.socket.on('d', //destroyed
      function(data) {
        let sh = this.ships.get(data.id);
        if(typeof sh !== 'undefined'){
          sh.pos.x = data.x;
          sh.pos.y = data.y;
          sh.destroyed(false);
        }
      }
    );

    this.socket.on('c', //comet
      function(data) {
        let timeDif = (currTime-data.t)/1000;
        let c = new Comet(data.x, data.y, data.vx, data.vy, data.r);
        c.move(timeDif);
        this.comets.push(c);
      }
    );

    //called once we connect
    this.socket.on('connected',
      function(data) {
        this.myId = data.id;
        this.myShip = new Ship(data.x,data.y);

        for(let i = 0; i < data.xs.length; i++){
          let a = new Asteroid(data.xs[i], data.ys[i], data.s[i]);
          this.asteroids.push(a);
        }
      }
    );
  }

  function update(){
    currTime = new Date().getTime();
    dt = (currTime - prevTime)/1000;

    background(0);
    verticalInput = 0;
    horizontalInput = 0;

    for(let a of this.asteroids){
      a.show();
    }

    for(let b of this.bullets.values()) {
      if(b.update()){
        b.onHit();
        this.bullets.delete(b.shooter + b.id);
      }
      else {
        b.move(dt);
        b.show();
      }
    }

    if(typeof this.myShip !== "undefined") {
      let changed = this.myShip.input();
      this.myShip.update();
      this.myShip.move(dt);
      
      gi++;
      if(gi%10 == 0 || changed) {
        this.myShip.sendData();
      }
      
      fill(255);
      this.myShip.show();
    }

    for(sh of this.ships.values()) {
      sh.move(dt);
      fill(0,255,255,255);
      sh.show();
    }

    for(let i = this.comets.length - 1; i >= 0; i--){
      let c = this.comets[i];
      if(c.update()){
        this.comets.splice(i, 1);
      }
      else {
        c.move(dt);
        c.show();
      }
    }

    for(let i = this.particles.length - 1; i >= 0; i--){
      let p = this.particles[i];
      p.update(dt);
      p.show();
      if(p.life == 0) {
        this.particles.splice(i, 1);
      }
    }

    prevTime = currTime;
  }
}